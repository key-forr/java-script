console.log(sum(1, 2));
// Помилки не буде, тому що оголошення (декларація) функції піднімається (hoisting) на початок області видимості.
// Це означає, що функція `sum` буде відома ще до виконання `console.log`, навіть якщо в коді вона оголошена нижче.

// Так само працює і var, тільки якщо ми в var достукаємось до значення то отримаємо undefined
function sum(a, b) {
  return a + b;
}
console.log(sum(1, 2));
// Також деклараційну функцію можна перезаписати
function sum(a, b) {
  return a + b + a;
}

function logAll() {
  console.log(arguments);
}

/* Це працює, тому що в JavaScript існує спеціальна змінна `arguments`, 
   яка містить усі передані аргументи, навіть якщо функція формально не приймає жодного параметра.

   У JavaScript функції можна передавати будь-яку кількість аргументів незалежно від того,
   скільки параметрів вона описує.

   Змінна `arguments` доступна лише в звичайних (декларативних) функціях, 
   але не працює в стрілкових функціях (`=>`). */

logAll("keyforr", 19, true);

const logHello = function () {
  // Expression function
  console.log("Hello world");
};

logHello();

// Різниця між деклараційною та expression функціями
/* 
    1. Функція чере (вираз) є змінною, тому її можна переписати, якщо використовуємо змінну типу let чи var.
       Однак, якщо ми використовуємо const, то переписати функцію не можна (буде помилка). 
       Простіше кажучи, це змінна, яка вказує на функцію, але в цю змінну можна записати будь-яке інше значення (не обов'язково функцію).
       Відповідно, це може створити непередбачувані ситуації, коли змінна, яка повинна вказувати на функцію, змінюється на інше значення.
       
    2. Функції, оголошені через declaration (дефініцію функції через `function`), підлягають hoisting. Тобто вони доступні
       у всій області видимості, навіть якщо викликаються до їхнього оголошення.
       
       В той же час, функції, оголошені через expression, не підлягають hoisting і доступні тільки після їхнього присвоєння змінній.
*/
